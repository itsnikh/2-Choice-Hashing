/*
 *
 * This is a server program which uses Select() as the blocking statement for contineous monitoring of any incoming TCP/UDP Packets.
 * In this Server.c File, for the incoming Packet, we will note the IP, Port, timestamp of the incoming connection.
 * Also, the counter value is also updated for each and every same IP and Protocol.
 * It uses API's Insert_packet(), Delete_packet() and Lookup_packet for insertion, modification,deletion of the Entered IP address.
 *
 */

/*
 * Here, the included file "hash.c" will include the Hash function which can also be found in same src folder
 */

#include "hash.c"	
/*
 * A function to clear the Bash screen, (Note: may not work on every computer)
 */
void clearscreen(void)
{
	printf("\033[H\033[J");
}
/*
 * This below function will assign the Client IP and save it to the struct Packet variable
 */
struct packet client_ip( struct sockaddr_in c)	
{
	struct packet a;
	unsigned char i;
	unsigned char name[INET_ADDRSTRLEN];

	inet_ntop(AF_INET,&c.sin_addr.s_addr, (char*)name,sizeof(name));

	for(i=0;name[i]!='\0';i++)
	   a.ip[i]=name[i];
	   a.ip[i]='\0';
	return a;
}

int main(void)
{
	struct sockaddr_in s,c;
	struct packet a;
	unsigned short tcp;
	unsigned short udp;
	unsigned short cfd;
	unsigned short client_socket[30], max_clients = 30 ;
	unsigned short sd, max_sd;
	unsigned short activity, i;
	unsigned char buf[SIZE], *htime;
	time_t current_time;
	fd_set fds;
	socklen_t len= sizeof(c);
	
/* 
 * Below are the necessary functions like Socket(), Bind(), Listen(), Accept(), Recvfrom()
 */

	if((tcp=socket(AF_INET,SOCK_STREAM,0))==0)
	{
		printf("Error in create TCP Socket\n\n");
		exit(EXIT_FAILURE);
	}

	if((udp=socket(AF_INET,SOCK_DGRAM,0))==0)
	{
		printf("Error in create UDP Socket\n\n");
		exit(EXIT_FAILURE);
	}	
/*
 * Do change the IP and Port according to the requirement 
 */
	s.sin_family=AF_INET;
	s.sin_addr.s_addr=INADDR_ANY;
	s.sin_port=htons(PORT);

	if((bind(tcp,(struct sockaddr *)&s, sizeof(s)))<0)
	{
		printf("Error in TCP Bind\n\n");
		exit(EXIT_FAILURE);
	}

	if((bind(udp,(struct sockaddr *)&s, sizeof(s)))<0)
	{
		printf("Error in UDP Bind\n\n");
		exit(EXIT_FAILURE);
	}

	if((listen(tcp,5))<0)
	{
		printf("\nError in Server Listen\n\n");
		exit(EXIT_FAILURE);
	}

	printf("\nWaiting for connections..!!\n");		

	while(1)
	{
		FD_ZERO(&fds);
		FD_SET(tcp,&fds);
		FD_SET(udp,&fds);		

       		for ( i = 0 ; i < max_clients ; i++) 
        	{

			sd = client_socket[i];
			if(sd > 0)
			FD_SET( sd , &fds);
			if(sd > max_sd)
			max_sd = sd;
		}
/* Monitors here for any incoming packet(s) */

		activity = select( max_sd + 1 , &fds , NULL , NULL , NULL);
		if ((activity < 0) && (errno!=EINTR))  
		{  
			printf("select error");  
		}
			/* for TCP Packets, below if statements stands TRUE */
		if(FD_ISSET(tcp,&fds))
		{
			if((cfd=accept(tcp,(struct sockaddr *)&c, &len))<0)
			{
				printf("ERROR in Accept!!\n\n");
				exit(-1);
			}
/* 
 * Read data send from Client
 */
			read(cfd, buf, SIZE);			
/* 
 * Assign the IP accordingly to the Incoming Packet
 */
			a=client_ip(c);
/*
 * Assign the Protocol as TCP
 */
			a.protocol= TCP;
/*
 * Check whether the data received from client contains "exit" as the string, if TRUE, Close the Server
 */
			if( ((strcmp((char*)buf,"exit"))==0) || ((strcmp((char*)buf,"EXIT"))==0) ) 
			{
				printf("\n\nClosing the Server!!\n\n");
				sleep(2);
				close(cfd);
				close(udp);
				close(tcp);
				exit(0);
			}
/* 
 * Check whether the data received from client contains "delete" as the string, if TRUE, Delete the entry of that Particular IP and Protocol
 */
			else if( strcmp((char*)buf,"delete")==0 || strcmp((char*)buf,"DELETE")==0 )
			{
				CLEAR;
				printf("\n\nFinding the IP ENTRY!!");
				delete_packet((void *) &a);
				display();
			}
/*
 * If Data is not "exit" or "delete", make it's entry in the Hash table according to the KEY which will be generated by the insert_packet() .
 */
			else
			{
				CLEAR;
/*
 * Fetch the time, port, data and store it temporarily in a struct packet variable
 */
				time(&current_time);
				htime=ctime(&current_time);
			
				a.port=ntohs(c.sin_port);

				for(i=0;htime[i]!='\0';i++)	
				   a.time[i]=htime[i];
				   a.time[i]='\0';

				for(i=0;buf[i]!='\0';i++)
				   a.data[i]=buf[i];
				   a.data[i]='\0';
/* 
 * Function calls to insert and display the Packet Entry in hash Table
 */
				insert_packet((void*)&a);
				display();
			}
		}
/* 
 * For UDP Packets, below if statements stands TRUE
 */
		else if(FD_ISSET(udp,&fds))
		{
			if((recvfrom(udp, buf, sizeof(buf), 0, (struct sockaddr *)&c, &len))<0)
				printf("\n\nError reading data!!");
/*
 * Assign the IP accordingly to the Incoming Packet
 */
			a=client_ip(c);
/*
 * Assign the Protocol as UDP
 */
			a.protocol= UDP;
/* 
 * Check whether the data received from client contains "exit" as the string, if TRUE, Close the Server
 */
			if( ((strcmp((char*)buf,"exit"))==0) || ((strcmp((char*)buf,"EXIT"))==0) )
			{
				printf("\n\nClosing the Server!!\n\n");
				close(cfd);
				close(udp);
				close(tcp);
				sleep(2);
				exit(0);
			}
/* 
 * Check whether the data received from client contains "delete" as the string, if TRUE, Delete the entry of that Particular IP and Protocol
 */
			else if( strcmp((char*)buf,"delete")==0 || strcmp((char*)buf,"DELETE")==0 )
			{
				CLEAR;
				printf("\n\nFinding the IP ENTRY!!");
				delete_packet((void*)&a);
				display();
			}
/*
 * If Data is not "exit" or "delete", make it's entry in the Hash table according to the KEY which will be generated by the insert_packet() .
 */
			else
			{
				CLEAR;
/* 
 * Fetch the time, port, data and store it temporarily in a struct packet variable
 */
				time(&current_time);
				htime=ctime(&current_time);

				a.port=ntohs(c.sin_port);

				for(i=0;htime[i]!='\0';i++)	
				   a.time[i]=htime[i];
				   a.time[i]='\0';

				for(i=0;buf[i]!='\0';i++)
				   a.data[i]=buf[i];
				   a.data[i]='\0';				
/* 
 * Function calls to insert and display the Packet Entry in hash Table
 */
				insert_packet((void*)&a);
				display();
			}
		} 

	close(cfd);		
	}	
close(tcp);
close(udp);
return 0;
}	
